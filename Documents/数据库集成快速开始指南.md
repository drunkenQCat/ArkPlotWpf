# 数据库集成快速开始指南

## 🚀 立即开始

### 第一步：环境准备

1. **确认当前状态**
   ```bash
   # 检查项目编译状态
   dotnet build
   
   # 运行现有测试
   dotnet test
   ```

2. **备份重要数据**
   ```bash
   # 备份JSON文件
   cp ArkPlotWpf/all_plots.json ArkPlotWpf/all_plots.json.backup
   cp ArkPlotWpf/all_plots_1.json ArkPlotWpf/all_plots_1.json.backup
   cp ArkPlotWpf/tags.json ArkPlotWpf/tags.json.backup
   ```

### 第二步：开始第一阶段实施

#### 2.1 创建缺失的Entity类

首先创建 `ActEntity`：

```csharp
// ArkPlotWpf/Data/Entities/ActEntity.cs
using System;

namespace ArkPlotWpf.Data.Entities;

public class ActEntity
{
    public long Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}
```

#### 2.2 创建 `ActRepository`

```csharp
// ArkPlotWpf/Data/Repositories/ActRepository.cs
using ArkPlotWpf.Data.Entities;
using ArkPlotWpf.Model;
using Dapper;

namespace ArkPlotWpf.Data.Repositories;

public class ActRepository : BaseRepository, IActRepository
{
    public ActRepository(string? connectionString = null) : base(connectionString)
    {
        DatabaseMigration.Migrate(_connectionString);
    }

    public async Task<Act> GetByTitleAsync(string title)
    {
        var entity = await QuerySingleOrDefaultAsync<ActEntity>(
            "SELECT * FROM Acts WHERE Title = @Title",
            new { Title = title });

        return entity?.ToModel();
    }

    public async Task<IEnumerable<Act>> GetAllAsync()
    {
        var entities = await QueryAsync<ActEntity>("SELECT * FROM Acts ORDER BY Title");
        return entities.Select(e => e.ToModel());
    }

    public async Task<long> AddAsync(Act act)
    {
        var entity = act.ToEntity();
        var sql = """
        INSERT INTO Acts (Title, CreatedAt, UpdatedAt)
        VALUES (@Title, @CreatedAt, @UpdatedAt);
        SELECT last_insert_rowid();
        """;

        return await ExecuteScalarAsync<long>(sql, entity);
    }

    public async Task<bool> UpdateAsync(Act act)
    {
        var entity = act.ToEntity();
        entity.UpdatedAt = DateTime.UtcNow;
        
        var sql = """
        UPDATE Acts 
        SET Title = @Title, UpdatedAt = @UpdatedAt
        WHERE Id = @Id
        """;

        var rowsAffected = await ExecuteAsync(sql, entity);
        return rowsAffected > 0;
    }

    public async Task<bool> DeleteAsync(long id)
    {
        var sql = "DELETE FROM Acts WHERE Id = @Id";
        var rowsAffected = await ExecuteAsync(sql, new { Id = id });
        return rowsAffected > 0;
    }
}
```

#### 2.3 创建 `ActMapper`

```csharp
// ArkPlotWpf/Data/Mappers/ActMapper.cs
using ArkPlotWpf.Data.Entities;
using ArkPlotWpf.Model;

namespace ArkPlotWpf.Data.Mappers;

public class ActMapper : IMapper<Act, ActEntity>
{
    public ActEntity ToEntity(Act model)
    {
        if (model == null)
            return null!;

        return new ActEntity
        {
            Id = model.Id,
            Title = model.Title,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
    }

    public Act ToModel(ActEntity entity)
    {
        if (entity == null)
            return null!;

        return new Act(entity.Title, new System.Text.StringBuilder())
        {
            Id = entity.Id
        };
    }
}
```

#### 2.4 创建接口

```csharp
// ArkPlotWpf/Data/Repositories/IActRepository.cs
using ArkPlotWpf.Model;

namespace ArkPlotWpf.Data.Repositories;

public interface IActRepository
{
    Task<Act> GetByTitleAsync(string title);
    Task<IEnumerable<Act>> GetAllAsync();
    Task<long> AddAsync(Act act);
    Task<bool> UpdateAsync(Act act);
    Task<bool> DeleteAsync(long id);
}
```

### 第三步：测试新功能

#### 3.1 创建测试

```csharp
// ArkPlotWpf.DbTests/Database/Repositories/ActRepositoryTests.cs
using ArkPlotWpf.Data.Repositories;
using ArkPlotWpf.Model;
using Xunit;

namespace ArkPlotWpf.DbTests.Database.Repositories;

public class ActRepositoryTests : IDisposable
{
    private readonly string _testDbPath;
    private readonly ActRepository _repository;

    public ActRepositoryTests()
    {
        _testDbPath = Path.GetTempFileName();
        _repository = new ActRepository($"Data Source={_testDbPath}");
    }

    public void Dispose()
    {
        try
        {
            if (File.Exists(_testDbPath))
            {
                File.Delete(_testDbPath);
            }
        }
        catch
        {
            // 忽略删除失败的情况
        }
    }

    [Fact]
    public async Task AddAct_ShouldReturnValidId()
    {
        // Arrange
        var act = new Act("TestAct", new System.Text.StringBuilder());

        // Act
        var id = await _repository.AddAsync(act);

        // Assert
        Assert.True(id > 0);
    }

    [Fact]
    public async Task GetByTitle_ShouldReturnCorrectAct()
    {
        // Arrange
        var act = new Act("TestAct", new System.Text.StringBuilder());
        await _repository.AddAsync(act);

        // Act
        var result = await _repository.GetByTitleAsync("TestAct");

        // Assert
        Assert.NotNull(result);
        Assert.Equal("TestAct", result.Title);
    }
}
```

#### 3.2 运行测试

```bash
cd ArkPlotWpf.DbTests
dotnet test --filter "ActRepositoryTests"
```

### 第四步：集成到现有服务

#### 4.1 更新 `PlotDataService`

```csharp
// 在 PlotDataService 中添加 ActRepository 支持
public class PlotDataService : IDisposable
{
    private readonly ActRepository _actRepository;
    // ... 其他现有代码 ...

    public PlotDataService(string initActName = "default")
    {
        // ... 现有初始化代码 ...
        _actRepository = new ActRepository(_connectionString);
    }

    public async Task<Act> GetActByNameAsync(string title)
    {
        return await _actRepository.GetByTitleAsync(title);
    }

    public async Task<IEnumerable<Act>> GetAllActsAsync()
    {
        return await _actRepository.GetAllAsync();
    }
}
```

### 第五步：验证集成

#### 5.1 运行完整测试套件

```bash
# 运行所有测试
dotnet test

# 检查测试覆盖率
dotnet test --collect:"XPlat Code Coverage"
```

#### 5.2 手动测试

```csharp
// 在 MainWindow.xaml.cs 中添加测试代码
private async void TestDatabaseIntegration()
{
    try
    {
        using var plotService = new PlotDataService();
        
        // 测试获取所有章节
        var acts = await plotService.GetAllActsAsync();
        MessageBox.Show($"找到 {acts.Count()} 个章节");
        
        // 测试获取特定章节
        var act = await plotService.GetActByNameAsync("default");
        if (act != null)
        {
            MessageBox.Show($"找到章节: {act.Title}");
        }
    }
    catch (Exception ex)
    {
        MessageBox.Show($"测试失败: {ex.Message}");
    }
}
```

## 📋 下一步计划

### 立即可以开始的任务

1. **创建 PlotEntity 和 PlotRepository**
   - 参考 ActEntity 的实现模式
   - 实现完整的 CRUD 操作
   - 添加相应的测试

2. **创建 FormattedTextEntryEntity 和 Repository**
   - 处理复杂的 JSON 字段映射
   - 实现与 Plot 的关联关系
   - 添加数据验证

3. **实现数据迁移服务**
   - 创建 JSON 到数据库的迁移脚本
   - 实现数据验证和清理
   - 添加备份和恢复功能

### 本周目标

- [ ] 完成所有 Entity 类的创建
- [ ] 完成所有 Repository 类的实现
- [ ] 完成所有 Mapper 类的实现
- [ ] 通过所有单元测试
- [ ] 实现基础的数据迁移功能

### 下周目标

- [ ] 重构现有服务类
- [ ] 实现新的服务接口
- [ ] 更新 ViewModel 层
- [ ] 添加异步操作支持
- [ ] 实现错误处理机制

## 🔧 常见问题解决

### 问题1：数据库连接失败
```csharp
// 检查连接字符串
var connectionString = $"Data Source={dbPath};Version=3;";
// 确保数据库文件路径存在
Directory.CreateDirectory(Path.GetDirectoryName(dbPath));
```

### 问题2：迁移脚本执行失败
```csharp
// 检查迁移版本
DatabaseMigration.Migrate(_connectionString);
// 确保所有SQL语句语法正确
```

### 问题3：测试数据清理失败
```csharp
// 使用 try-catch 包装清理代码
try
{
    if (File.Exists(_testDbPath))
    {
        File.Delete(_testDbPath);
    }
}
catch
{
    // 忽略清理失败
}
```

## 📞 获取帮助

如果在实施过程中遇到问题：

1. **查看现有测试**：参考 `PrtsDataRepositoryTests` 的实现
2. **检查异常处理**：查看 `DatabaseException` 类的使用
3. **验证数据映射**：参考 `PrtsDataMapper` 的实现模式
4. **运行测试**：确保每个步骤都有对应的测试验证

## 🎯 成功标准

完成第一阶段后，你应该能够：

- [ ] 成功创建和运行所有新的 Repository 类
- [ ] 所有测试通过，覆盖率 > 80%
- [ ] 数据库迁移系统正常工作
- [ ] 现有功能不受影响
- [ ] 新的数据访问层可以正常工作

准备好开始了吗？让我们开始第一阶段的实施！ 